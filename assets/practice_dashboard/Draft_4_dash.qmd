---
title: "Draft_4_dash"
author: "Grunwald Lab"
params:
  inputs: "../main_report/_test_data/xanthomonas/xan_test_inputs"
format: 
  dashboard:
    css: styles.css
    scrolling: true
logo: nf-core-plantpathsurveil_logo_light.png
theme: united
editor: visual
bibliography: references.bib
nocite: |
  @qin2014proposed, @kurtzer2017singularity, @anaconda
# adds literature citations that aren't referenced within the report - important when citation isn't associated with a program
---

```{r knitr_settings}
knitr::opts_chunk$set(echo = FALSE, fig.width = 8, warning = FALSE, message = FALSE)
```

```{r library}
library(dplyr)
library(ggplot2)
library(readr)
library(knitr)
library(purrr)
library(yaml)
library(ape)
library(magrittr)
library(pheatmap)
library(heatmaply)
library(tidyverse)
library(palmerpenguins)
library(ade4)
library(adegenet)
library(ggtree)
library(igraph)
library(visNetwork)
library(phangorn)
library(ggplot2)
library(ggnewscale)
library(kableExtra)
library(plotly)
library(webshot2)
library(ggdendro)
library(rcrossref)
library(devtools)
library(phylocanvas)
library(poppr)
library(metacoder)
library(psminer)
```

```{r Var1}
group <- report_group_parsed(params$inputs)
sample_data <- sample_meta_parsed(params$inputs)
```

```{r Var2}
threshold_options <- c(0.0001, 0.001, 0.01, 0.1)
align_data <- variant_align_path_data(params$inputs)
alignments <- variant_align_parsed(params$inputs)
alignments <- alignments[!unlist(lapply(alignments, is.null))]
align_data <- align_data[align_data$path %in% names(alignments), ]
sample_data <- sample_meta_parsed(params$inputs)
ref_data <- ref_meta_parsed(params$inputs)
```

```{r Var3}
top_hits <- sendsketch_parsed(params$inputs, only_best = TRUE)
unique_tax <- unique(sub(top_hits$taxonomy, pattern = ';s:(.+);.+$', replacement = ';s:\\1')) # ignore below species level information
is_single_taxon <- length(unique_tax) == 1
```

```{r Var4}
core_plots <- core_tree_plot(params$inputs, interactive = FALSE)
```

#  {.sidebar}

------------------------------------------------------------------------

This report is produced by the **`nf-core/pathogensurveillance` pipeline**.

-   **Report group:** `r group`
-   **Sample count:** `r nrow(sample_data)`
-   **Last updated:** `r format(Sys.time(), '%B %d , %Y')`
-   **Pipeline version:** {{< var version >}}

------------------------------------------------------------------------

# Results

## Row1

### Column 1

::: {.card title="Phylogeny"}
::: panel-tabset
## Phylo

This section includes phylogenetic trees of samples with references sequences downloaded from [RefSeq](https://www.ncbi.nlm.nih.gov/refseq/) meant to provide a reliable identification using genome-scale data. The accuracy of this identification depends on the presence of close reference sequences in RefSeq and the accuracy of the initial identification.

```{r results='asis'}
plot_one <- function(x) {
    print(core_plots[[x]])
}
tip_count <- sum(core_plots[[1]]$data$isTip)
max_label_size <- max(nchar(core_plots[[1]]$data$label))
print_figures_with_selector(plot_one, selector = list('Color By' = names(core_plots)), id_prefix = 'core-gene-phylo', width = 1700 + max_label_size * 30, height = 500 + tip_count * 60, res = 300)
```

```{r, results='asis', eval = length(core_tree_path(params$inputs)) > 0}
cat('
::: {.callout-tip collapse="true"}
## About this plot

This a core gene phylogeny of samples with reference genomes for context.
A core gene phylogeny uses the sequences of all gene shared by all of the genomes included in the tree to infer evolutionary relationships.
It is the most robust identification provided by this pipeline, but its precision is still limited by the availability of similar reference sequences.
:::
')
```

```{r, results='asis', eval = length(core_tree_path(params$inputs)) == 0}
cat('
Could not generate core genome phylogeny. No tree files found.
')
```

## SNP tree

```{r results='asis'}
snp_plots <- variant_tree_plot(params$inputs, interactive = FALSE)
plot_one <- function(x) {
    print(snp_plots[[x]])
}
tip_count <- sum(snp_plots[[1]]$data$isTip)
max_label_size <- max(nchar(snp_plots[[1]]$data$label))
print_figures_with_selector(plot_one, selector = list(Color = names(snp_plots)), id_prefix = 'snp-gene-phylo', width = 1700 + max_label_size * 30, height = 500 + tip_count * 60, res = 300)
```

```{r, results='asis', eval = length(snp_plots) > 0}
cat('
::: {.callout-tip collapse="true"}
## About this plot

This is a representation of a Single Nucleotide Polymorphism (SNP) tree, depicting the genetic relationships among samples in comparison to a reference assembly.

The tree is less robust than a core gene phylogeny and cannot offer insights on evolutionary relationships among strains, but it does offer one way to visualize the genetic diversity among samples, with genetically similar strains clustering together.

Question-does it make sense to be showing the reference within the tree?
:::
')
```

```{r div_no_snp_phylo, eval = length(snp_plots) <= 0}
cat('There is no tree to draw. See staus messages at the start of the report for details.')
```

## MSN

```{r plot_msns, results='asis', eval = length(alignments) > 0}
# Find which columns are used to provide colors to the trees, if any
ids_used <- unique(unlist(lapply(alignments, function(a) {
  if (is.null(a)) {
    return(character(0))
  } else {
    return(rownames(a))
  }
})))
color_by_cols <- unique(unlist(strsplit(sample_data$color_by[sample_data$sample_id %in% ids_used], split = ';')))
color_by_cols <- color_by_cols[! is.na(color_by_cols)]
color_by_col_names <- c(color_by_cols, 'Default')
color_by_cols <- c(as.list(color_by_cols), list(NULL))  # NULL ensures that the default color scheme is also used

plot_one <- function(ref_id, threshold, color_by) {
  align <- alignments[[align_data$path[align_data$ref_id == ref_id]]]
  align_without_ref <- align[rownames(align) != ref_id, ]
  psminer:::make_MSN(align_without_ref, sample_data, user_seed = 1, snp_diff_prop = threshold, population = color_by)
}

plot_vars <- list(
  Reference = align_data$ref_id,
  Threshold = threshold_options,
  'Color By' = unlist(color_by_cols)
)
print_figures_with_selector(plot_one, selector = plot_vars, id_prefix = 'snp-msn', width = 1500, height = 1500, res = 200)
```

```{r, results='asis', eval = length(alignments) > 0}
cat('
::: {.callout-tip collapse="true"}

## About this plot

This figure depicts a minimium spanning network (MSN).
The nodes represent unique multiocus genotypes, and the size of nodes is proportional to the # number of samples that share the same genotype.

The edges represent the SNP differences between two given genotypes, and the darker the color of the edges, the fewer SNP differences between the two.

Note: within these MSNs, edge lengths are not proportional to SNP differences.
:::
 ')
```

```{asis div_no_snp_align, echo = length(alignments) <= 0}
cat('
Could not generate minimum spanning networks. This is likely due to not having any FASTA SNP alignment inputs.
')
```
:::
:::

### Column 2

::: {.card title="ANI comparisons"}
```{r ANI_Variables}
ani_matrix <- estimated_ani_matrix_parsed(params$inputs)[[1]]
sample_data <- sample_meta_parsed(params$inputs)
reference_data <- ref_meta_parsed(params$inputs)
```

::: panel-tabset
## ANI heatmap

```{r ani_heatmap}
make_ani_heatmap(ani_matrix * 100, reference_data, sample_data, height= NULL, width = NULL)
```

::: {.callout-tip collapse="true"}
## About this plot

This plot shows the results of comparing the similarity of all samples and references to each other. These similarity metrics are based on the presence and abundance of short exact sequence matches between samples (i.e. comparisons of k-mer sketches). These measurements are not as reliable as the methods used to create phylogenetic trees, but may be useful if phylogenetic trees could not be inferred for these samples.
:::

## ANI table

```{r}
# Parse ANI matrix
print_ani_table(ani_matrix * 100, sample_data, reference_data)
```
:::
:::

## Row2

::: {.card .flow title="Practice Map"}
This is a practice at getting leaflet to work in my own dashboards.

```{r Practice_map2}
m <- leaflet() %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addMarkers(lng=174.768, lat=-36.852, popup="The birthplace of R")
m  # Print the map
```
:::

# About

The **`nf-core/pathogen surveillance` pipeline** was developed by: Zach Foster, Martha Sudermann, Camilo Parada-Rojas, Fernanda Iruegas-Bocardo, Ricardo Alcalá-Briseño, [Jeff Chang](http://changlab.cgrb.oregonstate.edu/) and [Nik Grunwald](http://grunwaldlab.cgrb.oregonstate.edu/).

Other contributors include: [Alex Weisberg](https://alexandra-weisberg.com/), ...

::: callout-tip
## Feedback

To contribute, provide feedback, or report bugs please visit our [github repository](https://github.com/nf-core/pathogensurveillance).
:::

Please cite this pipeline and nf-core in publications as follows:

Foster et al. 2024. PathogenSurveillance: A nf-core pipeline for rapid analysis of pathogen genome data. In preparation.

Di Tommaso, Paolo, Maria Chatzou, Evan W Floden, Pablo Prieto Barja, Emilio Palumbo, and Cedric Notredame. 2017. Nextflow Enables Reproducible Computational Workflows. Nature Biotechnology 35 (4): 316--19. https://doi.org/10.1038/nbt.3820.

Icons for this report were sampled from [Bootstrap Icons](https://icons.getbootstrap.com), [Freepick](https://www.freepik.com), [Academicons](https://jpswalsh.github.io/academicons/), and [Font Awesome](https://fontawesome.com).

## {{< bi gear-wide-connected >}} Analysis software

```{r}
# Parse version data
version_data <- software_version_parsed(params$inputs)

# Generate citation list based on contents of version data table, .bib file, and .csv file used to index .bib file with program names
reflist <- read.csv(file = 'references.csv')
version_data$citation <- reflist[match(version_data$program, reflist$program), 'citation']
knitr::kable(version_data)
```

## Row3

::: {#refs}
:::
